{\rtf1\ansi\ansicpg1252\cocoartf1343\cocoasubrtf140
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red100\green56\blue32;\red28\green0\blue207;\red196\green26\blue22;
\red170\green13\blue145;\red0\green116\blue0;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf2 \CocoaLigature0 #define	SIZE1 \cf3 13\cf0 \
\cf2 #define	SIZE2 \cf3 12\cf0 \
\
\cf2 #include \cf4 <iostream>\cf0 \
\cf2 #include \cf4 "binarySearchTree.h"\cf0 \
\
\cf5 using\cf0  \cf5 namespace\cf0  std;\
\
\cf5 int\cf0  list1[SIZE1] = \{\cf3 34\cf0 , \cf3 77\cf0 , \cf3 26\cf0 , \cf3 51\cf0 , \cf3 39\cf0 , \cf3 8\cf0 , \cf3 12\cf0 , \cf3 67\cf0 , \cf3 4\cf0 , \cf3 98\cf0 , \cf3 123\cf0 , \cf3 10\cf0 , \cf3 42\cf0 \};\
\cf5 int\cf0  list2[SIZE2] = \{\cf3 34\cf0 , \cf3 77\cf0 , \cf3 26\cf0 , \cf3 51\cf0 , \cf3 39\cf0 , \cf3 8\cf0 , \cf3 12\cf0 , \cf3 67\cf0 , \cf3 4\cf0 , \cf3 98\cf0 , \cf3 10\cf0 , \cf3 42\cf0 \};\
\
\cf5 int\cf0  main()\
\{\
	bSearchTreeType<\cf5 int\cf0 > tree1, tree2, tree3, tree4, tree5;\
\
	\cf5 for\cf0  (\cf5 int\cf0  i = \cf3 0\cf0 ; i < SIZE1; ++i) \{\
		tree1.insert(list1[i]);\
		tree3.insert(list1[i]);\
	\}\
\
	\cf5 for\cf0  (\cf5 int\cf0  i = \cf3 0\cf0 ; i < SIZE2; ++i) \{\
		tree2.insert(list2[i]);\
	\}\
\
	cout << \cf4 "Tree1:"\cf0  << endl;\
	cout << \cf4 "\\tHeight = "\cf0  << tree1.treeHeight() << endl;\
	cout << \cf4 "\\tinorder traversal = "\cf0 ;\
	tree1.inorderTraversal();\
	cout << endl;\
\
	cout << \cf4 "Tree2:"\cf0  << endl;\
	cout << \cf4 "\\tHeight = "\cf0  << tree2.treeHeight() << endl;\
	cout << \cf4 "\\tinorder traversal = "\cf0 ; \
	tree2.inorderTraversal();\
	cout << endl;\
\
	cout << \cf4 "Tree3:"\cf0  << endl;\
	cout << \cf4 "\\tHeight = "\cf0  << tree3.treeHeight() << endl;\
	cout << \cf4 "\\tinorder traversal = "\cf0 ; \
	tree3.inorderTraversal();\
	cout << endl;\
\
	cout << \cf4 "Tree4:"\cf0  << endl;\
	cout << \cf4 "\\tHeight = "\cf0  << tree4.treeHeight() << endl;\
	cout << \cf4 "\\tinorder traversal = "\cf0 ; \
	tree4.inorderTraversal();\
	cout << endl;\
\
	cout << \cf4 "Tree5:"\cf0  << endl;\
	cout << \cf4 "\\tHeight = "\cf0  << tree5.treeHeight() << endl;\
	cout << \cf4 "\\tinorder traversal = "\cf0 ; \
	tree5.inorderTraversal();\
	cout << endl;\
\
	\cf5 if\cf0  (tree1 == tree2) \{\
		cout << \cf4 "tree1 == tree2"\cf0  << endl;\
	\} \cf5 else\cf0  \{\
		cout << \cf4 "tree1 != tree2"\cf0  << endl;\
	\}\
\
	\cf5 if\cf0  (tree1 == tree3) \{\
		cout << \cf4 "tree1 == tree3"\cf0  << endl;\
	\} \cf5 else\cf0  \{\
		cout << \cf4 "tree1 != tree3"\cf0  << endl;\
	\}\
\
	\cf5 if\cf0  (tree1 == tree4) \{\
		cout << \cf4 "tree1 == tree4"\cf0  << endl;\
	\} \cf5 else\cf0  \{\
		cout << \cf4 "tree1 != tree4"\cf0  << endl;\
	\}\
\
	\cf5 if\cf0  (tree4 == tree5) \{\
		cout << \cf4 "tree4 == tree5"\cf0  << endl;\
	\} \cf5 else\cf0  \{\
		cout << \cf4 "tree4 != tree5"\cf0  << endl;\
	\}\
\
	\cf5 return\cf0  \cf3 0\cf0 ;\
\}\
===================================================\
\cf5 template\cf0 <\cf5 class\cf0  elemType>\
\cf5 const\cf0  binaryTreeType<elemType>& binaryTreeType<elemType>::\
           \cf5 operator\cf0 =(\cf5 const\cf0  binaryTreeType<elemType>& otherTree)\
\{\
    \cf5 if\cf0  (\cf5 this\cf0  != &otherTree) \cf6 //avoid self-copy\cf0 \
    \{\
        \cf5 if\cf0  (root != \cf5 NULL\cf0 )  \cf6 //if the binary tree is not empty,\cf0 \
                           \cf6 //destroy the binary tree\cf0 \
            destroy(root);\
\
        \cf5 if\cf0  (otherTree.root == \cf5 NULL\cf0 ) \cf6 //otherTree is empty\cf0 \
            root = \cf5 NULL\cf0 ;\
        \cf5 else\cf0 \
            copyTree(root, otherTree.root);\
    \}\cf6 //end else\cf0 \
\
    \cf5 return\cf0  *\cf5 this\cf0 ;\
\}}